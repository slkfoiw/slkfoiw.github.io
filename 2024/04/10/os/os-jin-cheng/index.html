<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="进程管理, CuberSugar&#39;s Blog">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>进程管理 | CuberSugar&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon_cube.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/cube.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">CuberSugar&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Home</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/cube.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">CuberSugar&#39;s Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Home
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/slkfoiw/slkfoiw.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/slkfoiw/slkfoiw.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/13.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">进程管理</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/OS/" class="post-category">
                                OS
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2024-04-10
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    10.2k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程概念的引入"><a href="#进程概念的引入" class="headerlink" title="进程概念的引入"></a>进程概念的引入</h2><h3 id="两个基本概念：并发与并行"><a href="#两个基本概念：并发与并行" class="headerlink" title="两个基本概念：并发与并行"></a>两个基本概念：并发与并行</h3><p>并发：宏观同时，微观交替</p>
<p>并行：同时</p>
<h3 id="并发性的确定–Bernstein条件"><a href="#并发性的确定–Bernstein条件" class="headerlink" title="并发性的确定–Bernstein条件"></a>并发性的确定–Bernstein条件</h3><p>定义：</p>
<ul>
<li>R(Si)：Si的读子集, 其值在Si中被引用的变量的集合</li>
<li>W(Si)：Si的写子集, 其值在Si中被改变的变量的集合</li>
</ul>
<p>Bernstein条件：</p>
<p>两个进程S1和S2可并发，当且仅当下列条件同时成</p>
<p>立：</p>
<ul>
<li>R(S1) ∩ W(S2) = Φ</li>
<li>W(S1) ∩ R(S2) = Φ</li>
<li>W(S1) ∩ W(S2) = Φ</li>
</ul>
<p>Bernstein条件是判断程序并发执行结果是否可再现的充分条件。</p>
<p>进程的定义和特征</p>
<ul>
<li>进程是程序的一次执行；</li>
<li>进程是可以和别的计算并发执行的计算；</li>
<li>进程可定义为一个数据结构，及能在其上进行操作的一个程序；</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动；</li>
<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li>
</ul>
<p>一个进程应该包括：</p>
<ul>
<li>程序的代码</li>
<li>程序的数据</li>
<li>PC中的值</li>
<li>一组通用的寄存器的当前值，堆、栈</li>
<li>一组系统资源（如打开的文件）</li>
</ul>
<p>进程与程序的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>进程</th>
<th>程序</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>动态</td>
<td>静态</td>
</tr>
<tr>
<td></td>
<td>暂时</td>
<td>永久</td>
</tr>
<tr>
<td>组成</td>
<td>程序、数据和进程控制块</td>
<td></td>
</tr>
<tr>
<td>两者之间的对应关系</td>
<td>通过多次执行，一个程序可以对应多个进程</td>
<td>通过调用关系，一个进程可包括多个程序</td>
</tr>
</tbody></table>
<h2 id="进程状态与控制"><a href="#进程状态与控制" class="headerlink" title="进程状态与控制"></a>进程状态与控制</h2><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>进程控制的主要任务是创建和撤销进程，以及实现进程的状态转换。<strong>由内核来实现</strong></p>
<h4 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h4><p>由若干条指令所组成的指令序列，来实现某个特定操作功能。</p>
<ul>
<li>指令序列是连续的，不可分割</li>
<li>是操作系统核心组成部分</li>
<li>必须在管态（内核态）下执行，且常驻内存</li>
</ul>
<p>与系统调用的区别：不可中断</p>
<p>创建原语：fork, exec</p>
<p>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建<strong>子进程的进程ID</strong>。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。如果出现错误，fork返回一个负值。</p>
<p>撤消原语：kill</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>就绪状态：进程已获得除处理机外的所需资源，等待分配处理机资源；只要分配CPU就可执行。</p>
<p>执行状态：占用处理机资源；处于此状态的进程的数目小于等于CPU的数目。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的idle进程（相当于空操作）。</p>
<p>阻塞状态：正在执行的进程，由于发生某种事件而暂时无法执行，便放弃处理机处于暂停状态</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">	A[执行状态] --&gt; |等待某个事件|B[阻塞状态]</span><br><span class="line">	B --&gt; |事件发生|C[就绪状态]</span><br><span class="line">	A --&gt; |时间片到|C</span><br><span class="line">	C --&gt; |调度|A</span><br></pre></td></tr></tbody></table></figure>

<h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>系统为每个进程定义了一个数据结构：进程控制块PCB（Process Control Block）。</p>
<p>作用：</p>
<ul>
<li>进程创建、撤消；</li>
<li>进程唯一标志；</li>
</ul>
<p>进程控制块是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消</p>
<p>内容：</p>
<ul>
<li>进程标识符：唯一。可以是字符串，也可以是一个数字（Linux系统中是一个整型数）。在进程创建时由系统赋予。</li>
<li>程序和数据地址</li>
<li>当前状态：为了管理的方便，系统设计时会将相同的状态的进程组成一个队列，如就绪进程队列，等待进程则要根据等待的事件组成多个等待队列，如等待打印机队列、等待磁盘I/O完成队列等等</li>
<li>现场保留区</li>
<li>互斥和同步机制：用于实现进程间互斥、同步和通信所需的信号量等</li>
<li>进程通信机制</li>
<li>优先级：反映进程的紧迫程度，通常由用户指定和系统设置。</li>
<li>资源清单：列出所拥有的除CPU外的资源记录，如拥有的I/O设备、打开的文件列表等。</li>
<li>链接字：根据进程所处的执行状态，进程相应的PCB加入到不同队列中。PCB链接字指出该进程所在队列中下一个进程PCB的首地址。</li>
<li>家族关系 …</li>
</ul>
<h3 id="PCB组织方式"><a href="#PCB组织方式" class="headerlink" title="PCB组织方式"></a>PCB组织方式</h3><p>线性表：适用于系统中进程数目不多的情况</p>
<p>索引方式：是线性表的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表。</p>
<h3 id="辨析：进程上下文切换vs陷入内核"><a href="#辨析：进程上下文切换vs陷入内核" class="headerlink" title="辨析：进程上下文切换vs陷入内核"></a>辨析：进程上下文切换vs陷入内核</h3><table>
<thead>
<tr>
<th></th>
<th>进程上下文切换（Process Context Switch</th>
<th>陷入/退出内核（也称为模态切换，Mode Switch）</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>通常由调度器执行，保存进程执行断点，切换内存映射(页表基址，flush TLB)</td>
<td>CPU状态改变，由中断、异常、Trap指令（系统调用）引起，需要保存执行现场（寄存器、堆栈等）</td>
</tr>
<tr>
<td></td>
<td>进程上下文切换过程一定会陷入内核</td>
<td>陷入内核不一定会导致进程切换</td>
</tr>
<tr>
<td></td>
<td></td>
<td>系统调用涉及到进程从用户态到内核态的切换（mode switch），这个时候涉及到的切换主要是寄存器上下文的切换，和通常所说的进程上下文切换不同，mode switch的消耗相对要小得多</td>
</tr>
</tbody></table>
<h2 id="线程概念的引入"><a href="#线程概念的引入" class="headerlink" title="线程概念的引入"></a>线程概念的引入</h2><h3 id="线程的提出"><a href="#线程的提出" class="headerlink" title="线程的提出"></a>线程的提出</h3><p>进程的不足：</p>
<ul>
<li>进程只能在一个时间处理一个任务，不能同时处理多个任务。</li>
<li>如果进程在执行时阻塞，整个进程都无法继续执行。</li>
</ul>
<p>需要一种新的实体，满足：</p>
<ul>
<li>实体之间可以并发地执行</li>
<li>实体之间共享相同的地址空间</li>
</ul>
<h3 id="进程与线程-1"><a href="#进程与线程-1" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>实际上，进程包含了两个概念：资源拥有者和可执行单元。现代操作系统<strong>将资源拥有者称为进程，将可执行单元称为线程</strong>。线程将资源与计算分离，提高并发效率。</p>
<table>
<thead>
<tr>
<th></th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>基本概念</td>
<td>程序的一次执行</td>
<td>进程中的可执行单元，进程中的一个实体，可以与其他同进程的线程共享进程拥有的所有资源，同时也拥有栈、PC等私有资源</td>
</tr>
<tr>
<td>资源共享</td>
<td>资源分配的单位，拥有运行程序所需要的全部资源</td>
<td>CPU调度的单位，只拥有必不可少的少量资源</td>
</tr>
<tr>
<td>系统开销</td>
<td>创建/撤销/切换/同步进程的开销大</td>
<td>系统开销小</td>
</tr>
<tr>
<td>并发程度</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<p>创建一个线程比一个进程快19-100倍。对于存在大量计算和大量I/O处理的应用，大幅度提高性能。在多CPU/多核CPU系统中更有优势。</p>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>线程在用户空间,通过library模拟的thread,不需要或仅需要极少的kernel支持。上下文切换比较快,因为不用更改page table等,使用起来较为轻便快速。提供操控视窗系统的较好的解决方案</p>
<p>优点：</p>
<ul>
<li>线程切换与内核无关</li>
<li>线程的调度由应用决定，容易进行优化。</li>
<li>可运行在任何操作系统上，只需要线程库的支持</li>
</ul>
<p>不足：</p>
<ul>
<li>很多系统调用会引起阻塞，内核会因此而阻塞所有相关的线程。</li>
<li>内核只能将处理器分配给进程，即使有多个处理器，也无法实现一个进程中的多个线程的并行执行</li>
</ul>
<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p>内核级线程就是kernel有好几个分身，一个分身可以处理一件事。这用来处理非同步事件很有用，kernel可以对每个非同步事件产生一个分身来处理。支持内核线程的操作系统内核称作多线程内核。</p>
<p>优点：</p>
<ul>
<li>内核可以在多个处理器上调度一个进程的多个线程实现同步并行执行</li>
<li>阻塞发生在线程级别</li>
<li>内核中的一些处理可以通过多线程实现</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个进程中的线程切换需要内核参与，线程的切换涉及到两个模式的切换（进程-进程、线程-线程）</li>
<li>降低效率</li>
</ul>
<h3 id="用户级线程和内核级线程的比较"><a href="#用户级线程和内核级线程的比较" class="headerlink" title="用户级线程和内核级线程的比较"></a>用户级线程和内核级线程的比较</h3><ul>
<li>用户级线程执行系统调用指令时将导致其所属进程的执行被暂停，而内核级线程执行系统调用指令时，只导致该线程被暂停。</li>
<li>在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核级线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度</li>
<li>用户级线程的程序实体是运行在用户态下的程序，而内核级线程的程序实体则是可以运行在任何状态下的程序</li>
</ul>
<h3 id="混合实现方式"><a href="#混合实现方式" class="headerlink" title="混合实现方式"></a>混合实现方式</h3><p>线程在用户空间创建和管理，需要实现从用户空间的线程到内核空间线程（轻量级进程）的映射。</p>
<h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><h2 id="同步与互斥问题"><a href="#同步与互斥问题" class="headerlink" title="同步与互斥问题"></a>同步与互斥问题</h2><p>临界资源：一次仅允许一个进程访问的资源。</p>
<p>临界区：每个进程中访问临界资源的那段<strong>代码</strong>称为临界区。</p>
<p>进程互斥：某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。互斥无法限制访问者对资源的访问顺序，即访问是<strong>无序访问</strong>。</p>
<p>进程同步：指<strong>在互斥的基础上</strong>，通过其他机制实现访问者对资源的<strong>有序访问</strong>。在大多数情况下，同步已经实现了互斥，特别是所有对资源的写入的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>
<p>临界区管理应满足的条件：</p>
<ul>
<li><strong>空闲让进</strong>：临界资源处于空闲状态，允许进程进入临界区。临界区内仅有一个进程运行。</li>
<li><strong>忙则等待</strong>：临界区有正在执行的进程，所有其他进程则不可以进入临界区。</li>
<li><strong>有限等待</strong>：对要求访问临界区的进程，应保证在有限时间内进入自己的临界区，避免死等。</li>
<li><strong>让权等待</strong>：当进程（长时间）不能进入自己的临界区时，应立即释放处理机，尽量避免忙等。</li>
</ul>
<h2 id="基于忙等待的互斥方法"><a href="#基于忙等待的互斥方法" class="headerlink" title="基于忙等待的互斥方法"></a>基于忙等待的互斥方法</h2><h3 id="软件方法"><a href="#软件方法" class="headerlink" title="软件方法"></a>软件方法</h3><h4 id="Dekker算法"><a href="#Dekker算法" class="headerlink" title="Dekker算法"></a>Dekker算法</h4><p>第一个不需要严格轮换的互斥算法。</p>
<p>引入变量turn，以便在竞争时选出进入临界区的进程</p>
<p>pturn/qturn表示“我”想进入临界区，turn表示该哪个进程进入临界区了（轮流进）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">P:</span><br><span class="line">......</span><br><span class="line">pturn = true;//I want to enter</span><br><span class="line">while(qturn) {// other wants to enter</span><br><span class="line">	if (turn == 1) {//it's not my turn</span><br><span class="line">		pturn = false;//I (temporarily) don't want to enter</span><br><span class="line">		while(turn == 1); // The other is automatically allowed to enter</span><br><span class="line">		// other don't want to enter</span><br><span class="line">		pturn = true;// I want to enter</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">// other doesn't want to enter</span><br><span class="line">//临界区</span><br><span class="line">turn = 1;// it's the other's turn</span><br><span class="line">pturn = false;// I don't want to enter</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Q:</span><br><span class="line">......</span><br><span class="line">qturn = true;</span><br><span class="line">while(pturn) {</span><br><span class="line">	if (turn == 0) {</span><br><span class="line">		pturn = false;</span><br><span class="line">		while(turn == 0);</span><br><span class="line">		qturn = true;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">//临界区</span><br><span class="line">turn = 0;</span><br><span class="line">qturn = false;</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>解决了互斥访问的问题，而且克服了强制轮流法的缺点，可以完全正常地工作。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define FALSE O</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define N 2 //进程的个数</span><br><span class="line">int turn; //轮到谁?</span><br><span class="line">int interested[N]; //兴趣数组，初始值均为FALSE</span><br><span class="line">void enter_region(int process)//process=0或1</span><br><span class="line">{</span><br><span class="line">	//另外一个进程的进程号</span><br><span class="line">    int other;</span><br><span class="line">    other = 1 - process;</span><br><span class="line">    //表明本进程感兴趣</span><br><span class="line">    interested[process]=TRUE;</span><br><span class="line">    turn = other;//设置标志位</span><br><span class="line">    //other也可以换成process，这其实是两种方式：谦让式vs争夺式</span><br><span class="line">    while(turn == other &amp;&amp; interested[other]==TRUE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void leave_region(int process) {</span><br><span class="line">	interested[process] = FALSE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Bakery-Algorithm-面包店算法"><a href="#Bakery-Algorithm-面包店算法" class="headerlink" title="Bakery Algorithm(面包店算法)"></a>Bakery Algorithm(面包店算法)</h4><ul>
<li>在进入临界区之前，进程收到一个数字，具有最小数字的进程被允许进入临界区</li>
<li>如果进程 Pi 和 Pj 接收到相同数字, if i &lt; j, then Pi 进入临界区；否则，Pj 进入临界区</li>
<li>产生的数字总是递增的，例如：1,2,3,3,3,3,4,5…</li>
</ul>
<h3 id="硬件方法"><a href="#硬件方法" class="headerlink" title="硬件方法"></a>硬件方法</h3><h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h4><p>使用“开关中断”指令。执行“关中断”指令，进入临界区操作；退出临界区之前，执行“开中断”指令。</p>
<p>优点：简单</p>
<p>缺点：</p>
<p>不适用于多CPU系统</p>
<p>往往会带来很大的性能损失。很多日常任务都是靠中断机制触发的，比如时钟，如果屏蔽中断，会影响时钟和系统效率。</p>
<p>用户进程的使用可能很危险，例如：关中断之后，不再打开中断，会导致整个系统无法继续运行。所以，使用范围一般为内核进程（少量使用）。</p>
<h4 id="使用test-and-set指令"><a href="#使用test-and-set指令" class="headerlink" title="使用test and set指令"></a>使用test and set指令</h4><p>TS（test-and-set ）是一种不可中断的基本原语（指令）。它会把“1”写到某个内存位置并传回其旧值。在多进程可同时访问内存的情况下，如果一个进程正在执行TS指令，在它执行完成前，其它的进程不可以执行TS指令。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">TestAndSet(boolean_ref *lock) { </span><br><span class="line">    boolean initial = *lock; </span><br><span class="line">    *lock = true; </span><br><span class="line">    return initial; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="自旋锁Spinlocks"><a href="#自旋锁Spinlocks" class="headerlink" title="自旋锁Spinlocks"></a>自旋锁Spinlocks</h4><p>利用test_and_set硬件原语提供互斥支持。通过对总线的锁定实现对某个内存位置的原子读与更新。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">acquire(int *lock) {</span><br><span class="line">    while(test_and_set(lock) == 1)</span><br><span class="line">    	/* do nothing */;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">release(int *lock) {</span><br><span class="line">	*lock = 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当lock == 0时，线程执行完acquire获得锁，lock被修改为1。其他线程想获得锁时，执行acquire会被卡在while循环里，直到获得线程的锁执行完释放锁。</p>
<h3 id="几个算法的共性问题"><a href="#几个算法的共性问题" class="headerlink" title="几个算法的共性问题"></a>几个算法的共性问题</h3><p>无论是软件还是硬件方法，解法都是正确的，但它们都有一个特点：当一个进程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止。造成：</p>
<ul>
<li>忙等待，浪费CPU时间</li>
<li>优先级反转：低优先级进程先进入临界区，高优先级进程一直忙等。如果使用用户级线程，低优先级线程不会被高优先级线程抢占(进入临界区一般需要系统调用，其他线程也同时会被阻塞)，因为抢占发生在进程级别。但是对于内核级线程的实现，这个是可能发生的。</li>
</ul>
<h4 id="补充：优先级反转"><a href="#补充：优先级反转" class="headerlink" title="补充：优先级反转"></a>补充：优先级反转</h4><p>是指一个低优先级的任务持有一个被高优先级任务所需要的共享资源。高优先任务由于因资源缺乏而处于受阻状态，一直等到低优先级任务释放资源为止。而低优先级获得的CPU时间少，如果此时有优先级处于两者之间的任务，并且不需要那个共享资源，则该中优先级的任务反而超过这两个任务而获得CPU时间。如果高优先级等待资源时不是阻塞等待，而是忙循环，则可能永远无法获得资源，因为此时低优先级进程无法与高优先级进程争夺CPU时间，从而无法执行，进而无法释放资源，造成的后果就是高优先级任务无法获得资源而继续推进。</p>
<ol>
<li>优先级置顶：给临界区一个高优先级，进入临界区的进程都将获得这个高优先级</li>
<li>优先级继承：当一个高优先级进程等待一个低优先级进程持有的资源时，低优先级进程将暂时获得高优先级进程的优先级别，在释放共享资源后，低优先级进程回到原来的优先级别</li>
<li>中断屏蔽：通过禁止中断来保护临界区，采用此种策略的系统只有两种优先级——可抢占优先级和中断禁止优先级。前者为一般进程运行时的优先级，后者为运行于临界区的优先级。</li>
</ol>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>将忙等变为阻塞。见下节</p>
<h2 id="基于信号量的同步方法"><a href="#基于信号量的同步方法" class="headerlink" title="基于信号量的同步方法"></a>基于信号量的同步方法</h2><p>同步中，进程经常需要等待某个条件的发生，如果使用忙等待的解决方案，势必浪费大量CPU时间。</p>
<p>解决方法：将忙等变为阻塞，可使用两条进程间的通信原语：Sleep和Wakeup。Sleep原语将引起调用进程的阻塞，直到另外一个进程用Wakeup原语将其唤醒。很明显，wakeup原语的调用需要一个参数——被唤醒的进程ID。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>是Dijkstra提出，它使用一个整型变量来累计唤醒次数，供以后使用。在他的建议中引入了一个新的变量类型，称作信号量（semaphore）。建议设立两种操作，P（也叫semWait）、V（也叫semSignal）。PV操作属于进程的低级通信。</p>
<p>信号量是一类特殊的变量，程序对其访问都是原子操作，且只允许对它进行P(信号变量)和V(信号变量)操作。</p>
<h3 id="信号量的定义"><a href="#信号量的定义" class="headerlink" title="信号量的定义"></a>信号量的定义</h3><p>一个确定的二元组(s, q)，其中s是一个具有非负初值的整型变量，q是一个初始状态为空的队列. 当发出P操作时：</p>
<ul>
<li>s为正，则该值等于可立即执行的进程的数量；s &lt;= 0，那么发出P操作后的进程被阻塞（即发出P操作后s先减一，此时若s&lt;0，则该进程被阻塞），│s │是被阻塞的进程数。</li>
<li>q是一个初始状态为空的队列，当有进程被阻塞时就会进入此队列。</li>
</ul>
<h3 id="信号量的分类"><a href="#信号量的分类" class="headerlink" title="信号量的分类"></a>信号量的分类</h3><p>二元信号量和一般信号量</p>
<ul>
<li>二元信号量：取值仅为“0”或“1”，主要用作实现互斥；</li>
<li>一般信号量：初值为<strong>可用物理资源的总数</strong>，用于进程间的协作同步问题。</li>
</ul>
<p>强信号量和弱信号量</p>
<ul>
<li><p>强信号量：进程从被阻塞队列释放时采取FIFO</p>
<p>–不会出现“饥饿”（某个进程长时间被阻塞）</p>
</li>
<li><p>弱信号量：没有规定进程从阻塞队列中移除顺序</p>
<p>–可能出现“饥饿“</p>
</li>
</ul>
<h3 id="信号量的操作"><a href="#信号量的操作" class="headerlink" title="信号量的操作"></a>信号量的操作</h3><ul>
<li>一个信号量可能被初始化为一个非负整数.</li>
<li>semWait 操作（P操作）使信号量减1。若值为负，则执行semWait的进程被阻塞。否则进程继续执行。</li>
<li>semSignal操作（V操作）使信号量加1。若值小于或等于零，则被semWait操作阻塞的进程被解除阻塞。</li>
</ul>
<h3 id="信号量在并发中的典型应用"><a href="#信号量在并发中的典型应用" class="headerlink" title="信号量在并发中的典型应用"></a>信号量在并发中的典型应用</h3><p>互斥：可以用初始值为1的信号量实现。一个进程在进入临界区之前执行P操作，退出临界区后执行V操作。这是实现临界区资源互斥使用的一个二元信号量。</p>
<p>有限并发：可以用初始值为c的信号量实现n（1&lt;=n&lt;=c)个进程的并发执行一个函数或一个资源。</p>
<p>进程同步：指当⼀个进程Pi想要执⾏⼀个ai操作时，它只在进程Pj执⾏完aj后，才会执⾏ai操作。可以⽤信号量如下实现：将信号量初始为0，Pi执⾏ai操作前执⾏⼀个semWait操作；⽽Pj执⾏aj操作后，执⾏⼀个semSignal操作。</p>
<p>屏障Barriers：只有当该线程/进程组中所有线程到达屏障点（可称之为同步点）时，整个程序才得以继续执行。信号量实现如下：n个进程就有n个信号量，屏障进入前对除本进程对应信号量以外的其他进程进行V操作，然后对本进程对应信号量进行P操作。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//两个进程</span><br><span class="line">semaphore s0 = 0</span><br><span class="line">semaphore s1 = 0</span><br><span class="line">P0:</span><br><span class="line">//code before barrier</span><br><span class="line">V(s0)</span><br><span class="line">P(s1)</span><br><span class="line">//code after barrier</span><br><span class="line"></span><br><span class="line">P1:</span><br><span class="line">//code before barrier</span><br><span class="line">V(s1)</span><br><span class="line">P(s0)</span><br><span class="line">//code after barrier</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//多个进程</span><br><span class="line">n = the number of threads</span><br><span class="line">count = 0//到达汇合点的线程数</span><br><span class="line">semaphore mutex = 1//互斥对count的访问</span><br><span class="line">semaphore barrier = 0 //线程到达之前都是0或者负值，到达后取正值</span><br><span class="line"></span><br><span class="line">P:</span><br><span class="line">P(mutex)</span><br><span class="line">count++</span><br><span class="line">if count == n:</span><br><span class="line">	V(barrier) //唤醒一个线程</span><br><span class="line">V(mutex)</span><br><span class="line"></span><br><span class="line">P(barrier)</span><br><span class="line">V(barrier)//一旦线程被唤醒，有责任唤醒下一个线程</span><br><span class="line"></span><br><span class="line">P(mutex)</span><br><span class="line">count--</span><br><span class="line">if count == 0:</span><br><span class="line">	P(barrier)//“关门”</span><br><span class="line">V(mutex)</span><br></pre></td></tr></tbody></table></figure>



<h3 id="P、V操作的优缺点"><a href="#P、V操作的优缺点" class="headerlink" title="P、V操作的优缺点"></a>P、V操作的优缺点</h3><p>优点：简单，而且表达能力强（用P、V操作可以<strong>解决任何同步、互斥问题</strong>）</p>
<p>缺点：不够安全，PV操作使用不当会出现死锁，遇到复杂同步互斥问题时实现复杂。</p>
<h2 id="基于管程的同步与互斥"><a href="#基于管程的同步与互斥" class="headerlink" title="基于管程的同步与互斥"></a>基于管程的同步与互斥</h2><h3 id="管程的定义和组成"><a href="#管程的定义和组成" class="headerlink" title="管程的定义和组成"></a>管程的定义和组成</h3><p>管程（Monitor）是在程序设计语言当中引入的一种高级同步机制。</p>
<p>一个管程定义了一个数据结构和能（在该数据结构上）被并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。（挺像Java里一个类的组成）</p>
<p>管程由四部分组成：</p>
<ol>
<li>管程的名称</li>
<li>局部于管程内部的共享数据结构（变量）说明</li>
<li>对该数据结构进行操作的一组互斥执行的过程（可以理解为函数 / Java里被synchronized的方法）</li>
<li>对局部于管程内部的共享数据设置初始值的语句</li>
</ol>
<h3 id="条件变量与信号量的区别"><a href="#条件变量与信号量的区别" class="headerlink" title="条件变量与信号量的区别"></a>条件变量与信号量的区别</h3><table>
<thead>
<tr>
<th>条件变量</th>
<th>信号量</th>
</tr>
</thead>
<tbody><tr>
<td>值不可增减</td>
<td>可增减</td>
</tr>
<tr>
<td>wait操作一定会阻塞当前进程</td>
<td>P操作只有当信号量的值小于0时才会阻塞</td>
</tr>
<tr>
<td>如果没有等待的进程，signal将会丢失</td>
<td>V操作增加了信号量的值，不会丢失</td>
</tr>
<tr>
<td>访问条件变量必须拥有管程的锁</td>
<td></td>
</tr>
</tbody></table>
<h2 id="进程通信（Interprocess-Communication）的主要方法"><a href="#进程通信（Interprocess-Communication）的主要方法" class="headerlink" title="进程通信（Interprocess Communication）的主要方法"></a>进程通信（Interprocess Communication）的主要方法</h2><ul>
<li><p>低级通信：只能传递状态和整数值（控制信息），包括进程互斥和同步所采用的信号量和管程机制。</p>
<p>缺点：传送信息量小；编程复杂</p>
</li>
<li><p>高级通信：适用于分布式系统、基于共享内存的多处理机系统、单处理机系统。</p>
<p>主要包括三类：管道、共享内存、消息系统</p>
</li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><h4 id="无名管道（Pipe）"><a href="#无名管道（Pipe）" class="headerlink" title="无名管道（Pipe）"></a>无名管道（Pipe）</h4><ul>
<li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li>
<li>只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；</li>
<li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是单独构成一种文件系统，并且<strong>只存在于内存</strong>中。</li>
<li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li>
</ul>
<h4 id="有名管道（Named-Pipe，又称FIFO）"><a href="#有名管道（Named-Pipe，又称FIFO）" class="headerlink" title="有名管道（Named Pipe，又称FIFO）"></a>有名管道（Named Pipe，又称FIFO）</h4><p>FIFO不同于无名管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。</p>
<p>注意：FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾</p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><ul>
<li>管程：过度依赖编译器；适用于单机环境。</li>
<li>消息传递——两个通信原语（OS系统调用）<ul>
<li>send (destination, &amp;message)</li>
<li>receive(source, &amp;message)</li>
</ul>
</li>
</ul>
<p>调用方式</p>
<ul>
<li>阻塞调用</li>
<li>非阻塞调用</li>
</ul>
<p>主要问题：</p>
<ul>
<li>解决消息丢失、延迟问题（TCP协议）</li>
<li>编址问题：mailbox</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是最有用的进程间通信方式，也是最快的IPC形式（因为它避免了其它形式的IPC必须执行的开销巨大的缓冲复制）。</p>
<p>两个不同进程A、B共享内存的意义是，同一块物理内存被映射到进程A、B各自的进程地址空间。当多个进程共享同一块内存区域，由于共享内存可以同时读但不能同时写，则需要同步机制约束（互斥锁和信号量都可以）。</p>
<p>共享内存通信的效率高（因为进程可以直接读写内存）。</p>
<p>进程之间在共享内存时，保持共享区域直到通信完毕。</p>
<h2 id="经典同步与互斥问题"><a href="#经典同步与互斥问题" class="headerlink" title="经典同步与互斥问题"></a>经典同步与互斥问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">semaphore empty = N//空闲数量</span><br><span class="line">semaphore full = 0//产品数量</span><br><span class="line">semaphore mutex = 1</span><br><span class="line">producer() {</span><br><span class="line">	while(true) {</span><br><span class="line">		P(empty);</span><br><span class="line">		P(mutex);</span><br><span class="line">		...</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(full)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">consumer() {</span><br><span class="line">	P(full)</span><br><span class="line">	P(mutex)</span><br><span class="line">	...</span><br><span class="line">	V(mutex)</span><br><span class="line">	V(empty)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="读者-写者"><a href="#读者-写者" class="headerlink" title="读者-写者"></a>读者-写者</h3><p>读者优先</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int readcount=0;//正在读的进程数</span><br><span class="line">semaphore rmutex=1;//用户readcount的互斥访问</span><br><span class="line">semaphore mutex=1;//用户数据访问的互斥</span><br><span class="line"></span><br><span class="line">read() {</span><br><span class="line">	P(rmutex)</span><br><span class="line">	if readcount == 0 then P(mutex)</span><br><span class="line">	readcount++</span><br><span class="line">	V(rmutex)</span><br><span class="line">	...</span><br><span class="line">	P(rmutex)</span><br><span class="line">	readcount--</span><br><span class="line">	if readcount == 0 then V(mutex)</span><br><span class="line">	V(rmutex)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">write(){</span><br><span class="line">	P(mutex)</span><br><span class="line">	...</span><br><span class="line">	V(mutex)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>读写公平(先来先服务)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int readcount=0;//正在读的进程数</span><br><span class="line">semaphore rmutex=1;//用户readcount的互斥访问</span><br><span class="line">semaphore mutex=1;//用户数据访问的互斥</span><br><span class="line">semaphore rwmutex = 1;</span><br><span class="line">read() {</span><br><span class="line">	P(rwmutex)</span><br><span class="line">	P(rmutex)</span><br><span class="line">	if readcount == 0 then P(mutex)</span><br><span class="line">	readcount++</span><br><span class="line">	V(rmutex)</span><br><span class="line">	V(rwmutex)</span><br><span class="line">	...</span><br><span class="line">	P(rmutex)</span><br><span class="line">	readcount--</span><br><span class="line">	if readcount == 0 then V(mutex)</span><br><span class="line">	V(rmutex)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">write(){</span><br><span class="line">	P(rwmutex)</span><br><span class="line">	P(mutex)</span><br><span class="line">    V(rwmutex)</span><br><span class="line">	...</span><br><span class="line">	V(mutex)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>写者优先(TODO</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">readSwitch = Lightswitch() </span><br><span class="line">writeSwitch = Lightswitch() </span><br><span class="line">noReaders = Semaphore(1) </span><br><span class="line">noWriters = Semaphore(1)</span><br><span class="line"></span><br><span class="line">Reader：</span><br><span class="line">noReaders.wait() </span><br><span class="line">	readSwitch.lock(noWriters)</span><br><span class="line">noReaders.signal()</span><br><span class="line">	# critical section for readers</span><br><span class="line">readSwitch.unlock(noWriters)</span><br><span class="line"></span><br><span class="line">Writer：</span><br><span class="line">writeSwitch.lock(noReaders) </span><br><span class="line">	noWriters.wait() </span><br><span class="line">		# critical section for writers </span><br><span class="line">	noWriters.signal() </span><br><span class="line">writeSwitch.unlock(noReaders) </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>最初信号量都是解锁态。如果reader在临界区，会给noWriter上锁。但是不会给noReader上锁。如果这时候writer到来，会给noReader加锁，会让后续读者排队在noReader。当最后一个读者离开，他会signal noWriter，这时写者可以进入。</p>
<p>当写者进入临界区，他同时拿着noreader和nowriter两个锁。一方面，其他读者和写者不能同时访问临界区。另一方面，writeSwitch 允许其他写者通过，并在noWriter等待。但是读者只能在noReader等待。这样，所有排队的写者能够通过临界区，而不需要signal noreader。当最后一个写者离开，noreader才解锁。写者才能进入。</p>
<h3 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h3><p>求解思路</p>
<ol>
<li>至多只允许四个哲学家同时（尝试）进餐,以保证至少有一个哲学家能够进餐,最终总会释放出他所使用过的两支筷子,从而可使更多的哲学家进餐。设置信号量room=4。（破除资源互斥）</li>
<li>对筷子进行编号，每个哲学家按编号从低到高拿起筷子。或者对哲学家编号，奇数号哲学家先拿左，再拿右；偶数号相反。（破除循环等待）</li>
<li>同时拿起两根筷子，否则不拿起。（破除保持等待）</li>
</ol>
<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="调度的类型"><a href="#调度的类型" class="headerlink" title="调度的类型"></a>调度的类型</h3><ul>
<li>高级调度：又称为“宏观调度”、“作业调度”。时间单位通常是分钟、小时、天</li>
<li>中级调度：又称为“内外存交换”</li>
<li>低级调度：又称为“微观调度”、“进程或线程调度”。时间单位通常是毫秒</li>
</ul>
<h3 id="面向用户的调度性能准则"><a href="#面向用户的调度性能准则" class="headerlink" title="面向用户的调度性能准则"></a>面向用户的调度性能准则</h3><ul>
<li><p>周转时间（批处理系统）：作业从提交到完成所经历的时间</p>
<p>带权周转时间 = 周转时间 / 服务时间（即执行时间）</p>
</li>
<li><p>响应时间（分时系统）：用户输入一个请求到系统给出首次响应的时间</p>
</li>
<li><p>截止时间（实时系统）：开始截止时间和完成截止时间，与周转时间有些相似</p>
</li>
<li><p>优先级</p>
</li>
<li><p>公平性</p>
</li>
</ul>
<h3 id="面向系统的调度性能准则"><a href="#面向系统的调度性能准则" class="headerlink" title="面向系统的调度性能准则"></a>面向系统的调度性能准则</h3><ul>
<li>吞吐量（批处理系统）：单位时间完成的作业数</li>
<li>处理机利用率（大中型主机）</li>
<li>各种资源的均衡利用（大中型主机）：如CPU繁忙的作业和I/O繁忙的作业搭配</li>
</ul>
<h3 id="调度算法本身的调度性能准则"><a href="#调度算法本身的调度性能准则" class="headerlink" title="调度算法本身的调度性能准则"></a>调度算法本身的调度性能准则</h3><ul>
<li>易于实现</li>
<li>执行/开销比小</li>
</ul>
<h2 id="设计调度算法要考虑的问题"><a href="#设计调度算法要考虑的问题" class="headerlink" title="设计调度算法要考虑的问题"></a>设计调度算法要考虑的问题</h2><ol>
<li><p>进程优先级（数）</p>
<p>优先级和优先数是不同的，优先级表现了进程的重要性和紧迫性，优先数实际上是一个数值，反映了某个优先级。</p>
<p>有静态、动态优先级之分，主要看优先级会不会在运行过程中改变。</p>
</li>
<li><p>进程优先级就绪队列的组织</p>
</li>
<li><p>抢占式调度与非抢占式调度</p>
</li>
<li><p>进程的分类</p>
<ol>
<li><p>I/O Bound（密集型）与CPU Bound</p>
</li>
<li><p>批处理进程、交互式进程、实时进程</p>
</li>
</ol>
</li>
<li><p>时间片</p>
</li>
</ol>
<h2 id="批处理系统的调度算法"><a href="#批处理系统的调度算法" class="headerlink" title="批处理系统的调度算法"></a>批处理系统的调度算法</h2><h3 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h3><p>特点：有利于长作业，不利于短作业；有利于CPU繁忙的作业，不利于I/O繁忙的作业</p>
<h3 id="最短作业优先（SJF）-短进程优先（SPN）"><a href="#最短作业优先（SJF）-短进程优先（SPN）" class="headerlink" title="最短作业优先（SJF）/短进程优先（SPN）"></a>最短作业优先（SJF）/短进程优先（SPN）</h3><p>这是对FCFS算法的改进，其目标是减少平均周转时间。做法是对预计执行时间短的作业（进程）优先分派处理机。<strong>通常后来的短作业不抢占正在执行的作业</strong>。</p>
<p>优点：与FCFS相比改善了平均（&amp;带权）周转时间、作业的等待时间；提高系统的吞吐量。</p>
<p>缺点：长作业可能长时间得不到执行；未能依据作业的紧迫程度来划分执行的优先级；难以准确估计作业的执行时间，从而影响调度性能。</p>
<h3 id="最短剩余时间优先（SRTF）"><a href="#最短剩余时间优先（SRTF）" class="headerlink" title="最短剩余时间优先（SRTF）"></a>最短剩余时间优先（SRTF）</h3><p>上面的方法SJF修改条件“通常后来的短作业不抢占正在执行的作业”为<strong>抢占式</strong></p>
<h3 id="最高响应比优先（HRRF）"><a href="#最高响应比优先（HRRF）" class="headerlink" title="最高响应比优先（HRRF）"></a>最高响应比优先（HRRF）</h3><p>实际上是FCFS算法和SJF算法的折衷既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业的等待时间过长，改善了调度性能。</p>
<p>在每次选择作业投入运行时，先计算后备作业队列中每个作业的响应比RP，然后选择其值最大的作业投入运行。<br>$$<br>RP = \frac{作业已等待时间 + 作业的服务时间}{作业的服务时间} = 1 + \frac{作业已等待时间}{作业的服务时间}<br>$$<br>响应比的计算时机：每当调度一个作业运行时，都要计算后备作业队列中每个作业的响应比，选择响应比最高者投入运行。</p>
<h2 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a>交互式系统的调度算法</h2><h3 id="时间片轮转-RR：Round-Robin）"><a href="#时间片轮转-RR：Round-Robin）" class="headerlink" title="时间片轮转(RR：Round Robin）"></a>时间片轮转(RR：Round Robin）</h3><h3 id="多级队列（MQ：Multi-level-Queue）"><a href="#多级队列（MQ：Multi-level-Queue）" class="headerlink" title="多级队列（MQ：Multi-level Queue）"></a>多级队列（MQ：Multi-level Queue）</h3><p>本算法引入多个就绪队列，通过各队列的区别对待，达到综合的调度目标；</p>
<p>不同队列可有不同的优先级、时间片长度、调度策略等；在运行过程中还可改变进程所在队列。如：系统进程、用户交互进程、批处理进程等</p>
<h3 id="多级反馈队列（MFQ：-Multi-level-Feedback-Queue-）"><a href="#多级反馈队列（MFQ：-Multi-level-Feedback-Queue-）" class="headerlink" title="多级反馈队列（MFQ： Multi-level Feedback Queue ）"></a>多级反馈队列（MFQ： Multi-level Feedback Queue ）</h3><p>是时间片轮转算法和优先级算法的综合和发展</p>
<ol>
<li>设置多个就绪队列，分别赋予不同的优先级（如逐级降低），队列1的优先级最高。每个队列执行时间片的长度也不同，规定<strong>优先级越低则时间片越长</strong>（如逐级加倍）。</li>
<li>新进程进入内存后，先投入队列1的末尾，按FCFS算法调度；若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按FCFS算法调度；如此下去，降低到最后的队列，则按“时间片轮转”算法调度直到完成。</li>
<li>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾</li>
<li>如果进程执行时有新进程进入较高优先级的队列，则<strong>抢先</strong>执行新进程，并把被抢先的进程投入<strong>原</strong>队列的末尾</li>
</ol>
<p><strong>优先级反转问题</strong></p>
<h2 id="实时系统的调度算法"><a href="#实时系统的调度算法" class="headerlink" title="实时系统的调度算法"></a>实时系统的调度算法</h2><p>实时系统是一种时间起着主导作用的系统。分为硬实时（绝对满足截止时间要求，如汽车和飞机的控制系统）和软实时（可以偶尔不满足）</p>
<h3 id="实时调度的前提条件"><a href="#实时调度的前提条件" class="headerlink" title="实时调度的前提条件"></a>实时调度的前提条件</h3><ul>
<li>任务集（S）是已知的；</li>
<li>所有任务都是<strong>周期性</strong>（T）的，</li>
<li>必须在限定的时限D内完成；</li>
<li>任务之间都是独立的，每个任务不依赖于其他任务；</li>
<li>每个任务的运行时间（c）是不变的；</li>
<li>调度, 任务切换的时间忽略不计</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li><p>静态表调度（Static table-driven scheduling）：通过对所有周期性任务的分析预测，事先确定一个固定的调度方案。</p>
</li>
<li><p>单调速率调度（RMS：Rate Monotonic Scheduling） 静态最优调度算法：任务的周期越小，其优先级越高，优先级最高的任务最先被调度；如果两个任务的优先级一样，当调度它们时，RM算法将随机选择一个调度。静态、<strong>抢先式调度</strong>。前提<br>  $$<br>  \sum_{i=1}^n \frac{C_i}{T_i} &lt;= n(\sqrt[n]{2} - 1) \to ln2 \approx 0.69 (n \to \infty)<br>  $$</p>
</li>
<li><p>最早截止时间优先算法（EDF：Earliest Deadline First）：任务的绝对截止时间越早，其优先级越高，优先级最高的任务最先被调度。如果两个任务的优先级一样，当调度它们时，RM算法将随机选择一个调度。<strong>抢占式</strong>。任务集可调度的充分必要条件(C是执行时间，T是周期)：<br>  $$<br>  \sum_{i=1}^n \frac{C_i}{T_i} &lt;= 1<br>  $$</p>
</li>
<li><p>最低松弛度优先算法（LLF：Least Laxity First）：根据任务紧急/松弛程度，来确定任务的优先级，使优先级高的优先执行。</p>
<p>  $$<br>  松弛度Laxity = 任务截止时间 - 本身剩余运行时间 - 当前时间<br>  $$</p>
<p>  调度时机：有任务执行完时，或有进程Laxity为0时（直接抢占）</p>
</li>
</ul>
<h2 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h2><p>与单处理机调度的区别：</p>
<ul>
<li>注重整体运行效率，而不是个别处理机的利用率</li>
<li>更多样的调度算法</li>
<li>多处理访问os数据结构时的互斥（对于共享内存的系统）</li>
</ul>
<p>调度单位广泛采用线程</p>
<ol>
<li><p>非对称式多处理系统(AMP：Asymmetric Multi-Processor)：指多处理器系统中各个处理器的地位不同。</p>
<ul>
<li><p>主－从处理机系统，由主处理机管理一个公共就绪队列，并分派进程给从处理机执行。</p>
</li>
<li><p>各个处理机有固定分工，如执行OS的系统功能，I/O处理，应用程序。</p>
</li>
<li><p>有潜在的不可靠性（主机故障造成系统崩溃）。</p>
</li>
</ul>
</li>
<li><p>对称式多处理系统（SMP）</p>
<ul>
<li><p>集中控制</p>
<ul>
<li><p>静态调度：每个CPU设立一个就绪队列，进程从开始执行到完成，都在同一个CPU上。</p>
<p>优点：调度算法开销小。</p>
<p>缺点：容易出现忙闲不均</p>
</li>
<li><p>动态调度：各个CPU采用一个公共就绪队列，<strong>队首</strong>进程每次分派到当前空闲的CPU上执行。可防止系统中多个处理器忙闲不均。</p>
</li>
</ul>
</li>
<li><p>分散控制</p>
<ul>
<li>自调度：所有CPU采用一个公共就绪队列，每个处理机都可以从队列中<strong>选择适当进程</strong>来执行。需要对就绪队列的数据结构进行<strong>互斥访问控制</strong>。最常用的算法，实现时易于移植，采用单处理机的调度技术</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><h3 id="死锁发生的四个必要条件"><a href="#死锁发生的四个必要条件" class="headerlink" title="死锁发生的四个必要条件"></a>死锁发生的四个必要条件</h3><ol>
<li>互斥条件：在一段时间内某资源只由一个进程占用</li>
<li>请求和保持条件：进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放</li>
<li>不可剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源</li>
</ol>
<h3 id="活锁livelock"><a href="#活锁livelock" class="headerlink" title="活锁livelock"></a>活锁livelock</h3><p>是指任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p>
<p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，即所谓的“活” ， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。避免活锁的简单方法是采用先来先服务的策略</p>
<h3 id="饥饿（starvation-："><a href="#饥饿（starvation-：" class="headerlink" title="饥饿（starvation)："></a>饥饿（starvation)：</h3><p>某些进程可能由于资源分配策略的不公平导致长时间等待。当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿，当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死</p>
<h2 id="处理死锁的基本方法"><a href="#处理死锁的基本方法" class="headerlink" title="处理死锁的基本方法"></a>处理死锁的基本方法</h2><ul>
<li><p>不允许死锁发生</p>
<p>预防死锁（静态）：防患于未然，破坏死锁的产生条件</p>
<p>避免死锁（动态）：在资源分配前进行判断</p>
</li>
<li><p>允许死锁发生</p>
<p>检测与接触死锁</p>
<p>无所作为：鸵鸟算法</p>
</li>
</ul>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><h4 id="安全序列"><a href="#安全序列" class="headerlink" title="安全序列"></a>安全序列</h4><p>安全序列的定义：一个序列{P1，P2，…，Pn}安全的，是指若对于每一个进程Pi，它需要的资源可以被系统中当前可用资源加上所有进程Pj（j &lt; i）当前占有资源之和所满足，则{P1，P2，…，Pn}为一个安全序列。</p>
<p>如果系统不存在这样一个安全序列，则系统是不安全的。</p>
<p>系统进入不安全状态也未必会产生死锁。产生死锁后系统一定处于不安全状态</p>
<h4 id="银行家算法-避免死锁算法"><a href="#银行家算法-避免死锁算法" class="headerlink" title="银行家算法(避免死锁算法)"></a>银行家算法(避免死锁算法)</h4><p>设n为进程数量，m为资源类型数量</p>
<ul>
<li>可利用资源向量Available：m维向量</li>
<li>最大需求矩阵Max：n x m 矩阵</li>
<li>分配矩阵Allocation：n x m矩阵</li>
<li>需求矩阵Need：n x m矩阵</li>
</ul>
<p>$$<br>Need(i, j) = Max(i,j) - Allocation(i,j)<br>$$</p>
<p><img src="/../../images/OS/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95.png" alt="银行家算法"></p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><h4 id="资源分配图-进程-资源图"><a href="#资源分配图-进程-资源图" class="headerlink" title="资源分配图/进程-资源图"></a>资源分配图/进程-资源图</h4><p>用有向图描述系统资源和进程的状态。二元组G=（ N， E），N： 结点的集合，N=P∪R。</p>
<p>P为进程， R为资源，P = {p1, p2, … , pn}，R = {r1, r2, … , rm}，两者为互斥资源。E：有向边的集合，e属于E，e = (pi , rj ) 或e = (rj , pi )。</p>
<ul>
<li>e = (pi, rj)是请求边，进程pi请求一个单位的rj资源；</li>
<li>e = (rj, pi)是分配边，为进程pi分配了一个单位的rj资源</li>
</ul>
<h4 id="资源分配图-RAG-算法"><a href="#资源分配图-RAG-算法" class="headerlink" title="资源分配图(RAG)算法"></a>资源分配图(RAG)算法</h4><p>资源分配图的化简：首先，找到一个非孤立点进程结点且只有分配边，去掉分配边，将其变为孤立结点。接着，将相应的资源分配给一个等待该资源的进程，即将某进程的申请边变为分配边。重复以上步骤，直到所有进程化简完成，即进程与资源间无连线，则系统无死锁</p>
<p>在经过一系列的简化后，若能消去图中的所有边，使所有的进程都成为孤立结点，则称该图是<strong>可完全化简的</strong>；反之的是<strong>不可完全化简的</strong></p>
<p><strong>死锁定理</strong>：系统中某个时刻t为死锁状态的充要条件是t时刻系统的资源分配图是不可完全化简的。</p>
<h3 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h3><p>剥夺资源</p>
<p>撤销进程</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">CuberSugar</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://slkfoiw.github.io/2024/04/10/os/os-jin-cheng/">https://slkfoiw.github.io/2024/04/10/os/os-jin-cheng/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">CuberSugar</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2024/04/20/dl/yolo-world/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="视觉开发认知和检测">
                        
                        <span class="card-title">视觉开发认知和检测</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-04-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/deepLearning/" class="post-category">
                                    deepLearning
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/03/22/os/os-nei-cun-guan-li/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="内存管理">
                        
                        <span class="card-title">内存管理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-03-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/OS/" class="post-category">
                                    OS
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2024-2025</span>
            
            <span id="year">2024</span>
            <a href="/about" target="_blank">CuberSugar</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">94.9k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/slkfoiw" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:wxbcly@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
